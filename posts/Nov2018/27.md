# Day 0

## Why I'm Doing This

Today I began my journey into learning Common Lisp. Exciting! Let me first start by telling you *why* I decided to learn Common Lisp. A friend and I are working on a project that needs to implement a conversational interface where the bot on the backend has knowledge of a wide variety of topics. We realized that the method we were planning on using was probably not gonna work because of how brittle it might be. This lead us to [Mind AI](https://www.mind.ai/). It implements something very similar to what we were planning on doing, except it's approach doesn't rely on probabilistic machine-learning models (which is *exactly* what we needed). Unfortunately, the Mind engine probably won't be live for awhile. In the meantime, I'm trying to figure out how to prepare so that when it launches (or at least when they have code on GitHub), I can dive right into their infrastructure and start contributing and building features on top of it that I'm gonna need for the project. Looking around their site a bit more, it seemed that they have a whole bunch of Lisp engineers working on the project. I thought this was odd at first but not for long. All I knew about Lisp was that it was really popular for writing symbolic AI applications in the 80s. I thought it had died along with the following AI winter. But I was wrong. It makes sense that Mind is looking to use Lisp since their project is essentially a decentralized, global symbolic AI. So it seemed that in order to contribute to this project and understand the source code, I'd have to learn Lisp.

This was fine by me since I love learning a new programming language. Especially one that's not really like any other language I've ever used. And reading more into it, I found out that Common Lisp (CL) is kind of the "standard" dialect of Lisp that has stood the test of time and is still being updated today. And reading a bit about Common Lisp, I saw it referred to over and over as "the programmable programming language." I was intrigued to say the least.

I was also reading the other day in [Atomic Habits](https://www.amazon.com/Atomic-Habits-Proven-Build-Break-ebook/dp/B07D23CFGR/ref=sr_1_2?ie=UTF8&qid=1543347983&sr=8-2&keywords=atomic+habits+james+clear) by James Clear (just finished it by the way; great book) about a YouTuber named Thomas Frank who has a tweet that goes out automatically everyday at 6:10 AM if he hasn't woken up yet that allows the first 5 repliers to each claim $5 from him. This is how he disincentivizes himself from waking up late in the morning. With that in mind I thought "why not apply this to learning CL?" So I made this repository to make it official and tweeted it out. So here I am.

## What I Did Today

I began by reading Chapters 1 and 2 of [Practical Common Lisp](http://www.gigamonkeys.com/book/) by Peter Seibel. I found it by searching around finding where to begin and someone [also recommended it to me on Twitter](https://twitter.com/RainerJoswig/status/1067362409462026240). Chapter 1 detailed how he became a CL programmer and "what's so great about Lisp." Chapter 2 covered getting a Common Lisp environment setup so that we could use the read-eval-print loop (REPL) to write some basic CL syntax.

I didn't follow the instructions for setting up the environment, instead I used [this](http://www.jonathanfischer.net/modern-common-lisp-on-osx/) tutorial for getting an environment set up on macOS.

Seibel introduced self-evaluating objects and lists. I found out that quite a lot of things (maybe all?) in CL are lists. To call a function you have to put it in a list. To do addition, you have a list where the first element is an addition operator and the remaining elements in the list are numebrs you want to find the sum of. For example `(+ 2 8)` would evaluate to `10` This was different. And very cool. I like the idea of most things being lists. We also got to write a simple, classic "Hello World" program in the chapter. It's simple, but exciting. We also saved and loaded a CL file as well as compiled it to a "fast-load file" (FASL). That's all for today! This was maybe an hour to an hour and a half of work.